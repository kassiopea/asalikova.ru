<!DOCTYPE HTML>
<html>
	<head>
        <!-- Google Tag Manager -->
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-5QPB2DJ');</script>
        <!-- End Google Tag Manager -->
		<meta charset="utf-8">
			<title>HTML, CSS, JS. С чего начать</title>
			<link rel="stylesheet" type="text/css" href="css/reset.css">
			<link rel="stylesheet" type="text/css" href="css/style-main.css">
            <link rel="stylesheet" href="css/YouTubePopUp.css">
			<link rel="shortcut icon" href="images/minlogo.png" type="image/png">
			<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
            <meta name="keywords" content="js, css, html, статьи об обучении">
            <meta name="description" content="статья находится в разработке">
	</head>
	<body>
        <!-- Google Tag Manager (noscript) -->
        <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5QPB2DJ"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
        <!-- End Google Tag Manager (noscript) -->

		<div class="wrapper">
    		<div class="header">
    			<div class="logo"><a href="index.html"><img src="images/logo-main.png" alt="logo"></a></div>

    			<nav>
    			    <a class="menu-trigger">меню</a>
    				<ul>
                        <li><a href="photo-portfolio.html">фото портфолио</a></li>
                        <li><a href="adobe.html">тонкости Adobe</a></li>
                        <li><a href="office-works.html">работа с Office</a></li>
                        <li><a href="my-blog.html">Мой блог</a></li>
                        <li><a href="aboutIT.html" class="active">около IT</a></li>
                        <li><a href="qa.html">тестирование ПО</a></li>
                    </ul>
    			</nav>
    		</div>
		
    		<div class="content">
                <div class="wrap-office-article">
                    
                    <article class="office-articles">
                        
                        <h2>Сетевые протоколы</h2>
                        
                        <div class="full-text-article-office aboutIT-article">

                        <p>Я просмотрела несколько лекций на youtube про модель OSI, сетевые протоколы. И собрала основные термины, тезисы и определения.
                        Предлагаю, для начала, отталкиваться от представленной ниже схемы (модели OSI).</p>
                        <img src="images/articles/aboutIt-article4-1.jpg" alt="7 model OSI">
                        <p>На первый взгляд - очень устрашающе, но при детальном рассмотрении становится понятно, как устроена сеть и схема превращается в шпаргалку для наглядного представления работы сети. Оговорюсь, что пройдемся мы только по поверхности "Луны", не вдаваясь в подробности. Я не ставила перед собой цель погрузиться на дно изучаемой темы. Полагаю, что для расширения кругозора просмотренного и усвоенного материала вполне достаточно. И главное, есть фундамент для того, чтобы при желании углубиться в изучение модели, методов, принципов и проч. Также, в конце статьи-конспекта я оставлю все ссылки на ресурсы, откуда черпала информацию.</p>
                        
                        <p>Что ж, начнем с взаимодействия протоколов в сети. <b>Протокол - это соглашение, в котором описано в каком виде данные должны передаваться. Протоколы действуют на 7 различных уровнях.</b></p>
                        <ol class="lists-style">
                            <li>Физический уровень (physical)</li>
                            <li>Канальный уровень (data link)</li>
                            <li>Сетевой уровень (network)</li>
                            <li>Транспортный уровень (transport)</li>
                            <li>Сеансовый уровень (session)</li>
                            <li>Представительский уровень (presentation)</li>
                            <li>Прикладной уровень (application)</li>
                        </ol>

                        <p>Каждый уровень решает свою задачу.</p>
                        <p><b>Физический уровень</b> - управление средой, сигналом, кодирование потоков битов. Этот уровень решает задачу передачи данных локальной сети, иначе, отвечает за то, как должно работать железо, которое передает данные (описание железа)</p>
                        <p><b>Канальный уровень</b> решает задачу физической адресации, передачи между двумя интерфейсами (описание протоколов, которые работают с этим железом).</p>
                        <p><b>Сетевой уровень</b> отвечает за логическую адресацию, передачу между двумя хостами, передачу в <a class="article-links" href="https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%82%D0%B5%D1%80%D0%BE%D0%B3%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C" target="_blank">гетерогенных сетях</a>. В частности, IP, глобальная адресация.</p>
                        <p><b>Транспортный уровень</b> отвечает за надежную доставку передачи между двумя приложениями, управление потоком байтов.</p>
                        <p><b>Сеансовый уровень</b> отвечает за поддержание сеанса связи, позволяя приложениям взаимодействовать между собой длительно время. Уровень управляет созданием/завершением сеанса, обменом информацией, синхронизацией задач, определением права на передачу данных. Службы сеансового уровня обысно используются в средах приложений, в которых требуется использование удаленного вызова процедур.</p>
                        <p><b>Представительский уровень</b> отвечает за преобразование протоколов и кодирование/декодирование данных. Запросы приложений, полученный с уровня приложений, он преобразует в формат для передачи по сети, а полученные по сети данные преобразует в формат, понятный приложениям.</p>
                        <p><b>Прикладной уровень</b> обеспечивает взаимодействие сети и пользователя. Уровень разрешает приложениям пользователя иметь доступ к сетевым службам, таким, как обработчик запросов к базам данных, доступ к файлам, пересылке электронной почты. А также отвечает за передачу служебной информации, предоставляет информацию об ошибках, формирует запросы к уровню представления.</p>

                        <p>Протоколы работают один поверх другого. <b>Протоколы верхнего уровня являются данными для протоколов нижнего уровня.</b> То есть, каждый уровень оборачивается в заголовки и спускается на уровень ниже (протоколы инкапсулируются друг с другом). Некоторые протоколы работают на двух уровнях сразу. Некоторые протоколы связаны между собой. Например, физический и канальный уровни работают в тесной связке.</p>

                        <h2>Ethernet</h2>
                        <p>Работает на двух нижних уровнях. Обеспечивает передачу данных внутри локальной сети. Протокол с общей средой. На 1 уровне (физическом) описывается какими свойствами должен обладать кабель, максимальная длина,  количество машин, которое можно подсоединить через него, какого рода сетевая карта должна передавать сигнал (параметры). Для передачи бита, в частности, используется <b>манчестерский код</b>.</p>
                        <blockquote class="blockquote-article">В начале каждого такта может происходить служебный перепад сигнала, если нужно представить несколько единиц или нулей подряд. Так как сигнал изменяется по крайней мере один раз за такт передачи одного бита данных, то манчестерский код обладает хорошими самосинхронизирующими свойствами.</blockquote>
                        
                        <p>Предполагается совместное использование среды. Если две машины хотят одновременно что-то передать, происходит коллизия. Коллизию отслеживает сетевая карта. Если обнаруживается коллизия, то сетевая карта повторяет попытку через случайное количество времени. Таким образом избегается ситуация одновременной передачи. <b>На канальном уровне</b> предполагается описание форматов передачи данных. Что в этих битах надо передавать. Описан формат кадра. 
                        
                        <img src="images/articles/format-kadr.jpg" alt="формат кадра канальный уровень модель OSI">

                        Преамбула (7 байт) - стабилизация среды <br>
                        SFD (0xab) - начало кадра <br>
                        MAC адреса (broadcast, interface) <br>
                        Протокол верхнего уровня <br>
                        Данные - до 1500 байт <br>
                        CRC-32  - контрольная сумма <br>
                        EFD - конец кадра
                        </p>
                        <h2>HUB, Switch, ARP</h2>
                        <p>При подключении к одному кабелю возникает несколько проблем: ограничена длина, количество подключенных машин (потому что возникают коллизии). Чтобы решить проблему с длинной, то есть с затуханием канала, были созданы простые сетевые устройства HUBы - ретрансляторы. У хаба есть несколько портов, он принимает сигнал на одном порту и применяет на все остальные, то есть ретранслирует его. Поэтому можно сделать сеть большего размера. Но коллизии при этом не исчезнут.</p>
                        <img src="images/articles/hub.jpg" alt="hub работа канальный уровень модель OSI">

                        <p>Чтобы уменьшить количество коллизий, были созданы устройства следующего уровня, которые называются Switch.</p> 

                        <p>Switch запоминает на каком порту какой mac адрес у него находится. Поэтому, когда получает инфо с мак адресом, он ретранслирует его только на порт с мак адресом (не затрагивая другие). Другими словами, он делит сеть на независимые сегменты.
                        </p>
                        <p>Проблемы, которые возникают с передачей данных в локальной сети:</p>
                        <p><b>Физические ограничения:</b></p>
                        <ul class="articles-lists-ul">
                            <li>Затухание</li>
                            <li>Коллизии</li>
                        </ul>
                        <p><b>Ограничение числа хостов:</b></p>
                        <ul class="articles-lists-ul">
                            <li>Сложность топологии</li>
                            <li>Огромные таблицы коммутации</li>
                        </ul>
                        <p><b>Несовместимость различных архитектур.</b></p>
                        <p>Можно увеличить количество Switch. Но тогда возникает вопрос о том, как передавать данные - сложность топологии. Из-за большого количества элементов сети, она начинает работать медленно. Поэтому, на определенном уровне, необходимо сеть делить уже с помощью маршрутизаторов.
                        </p>
                        <p>Под несовместимостью различных архитектур предполагается, что просто так подключить сеть с ethernet и, например, сеть с wi-fi не получится, так как это несовместимые технологии.
                        </p>
                        <p>Для объединения локальных сетей используется третий уровень (сетевой). На сетевом уровне у нас работает <b>протокол IP</b>.</p>
                        <h2>Протокол IP</h2>
                        <p>В сети IP есть маршрутизаторы. Они знают про IP адреса. Администратор прописывает в маршрутизаторе, какие IP адреса находятся в каждом из его портов.IP, маска сети и маршрутизатор по умолчанию прописываются по умолчанию.
                        </p>
                        <p>Как происходит передача данных? Сначала IP сопоставляется с маской сети. Маска сети говорит, что, например, первые 3 байта относятся к данной сети. Если эти 3 байта совпадают с получателем, значит оба IP находятся в одном сегменте сети (на одном порту роутера). В этом случае нет смысла использовать протокол IP. Тогда работает протокол ARP, который распознает мак адрес и передает данные получателю внутри одного сегмента сети. Если компьютер определяет, что IP адреса отправителя и получателя находятся в разных сетях, то данный пакет передается маршрутизатору. Маршрутизатор может передать пакет другому маршрутизатору и так до тех пор, пока он не дойдет до точки назначения. 
                        </p>
                        <p><b>Задачи протокола IP</b></p>
                        <ul class="articles-lists-ul">
                            <li>Глобальная адресация</li>
                            <li>Передача в гетерогенной сети (сегментация)</li>
                            <li>Маршрутизация пакетов</li>
                        </ul>

                        <p>С помощью Ethernet нельзя глобально передать данные, потому что они не обладают одной определенной структурой. Протокол IP решает задачу глобальной адресации, то есть дает уникальные адреса. Позволяет передавать данные в разнородных системах (геторогенных сетях).</p>
                        <img src="images/articles/IP.jpg" alt="IP адрес протоколы сети модель OSI">
                        <p>Этот формат стоит читать в битовом представлении. Тогда получается 31 уровень. Если мы решим, что старшие 23 бита неизменны (маска подсети), то адреса этой подсети варьируются в последних 8 бит (255 разных окончаний). 34.1 - обычно адрес айпишника роутера, который организует маленькую подсеть. Каждый роутер строит таблицу маршрутов, знает как быстрее отправить данные на IP</p>
                        <p><b>Примеры IP адресов:</b><br><br>
                        94.100.191.201 - один из адресов мейл.ру<br>
                        127.0.0.1 - адрес локального компьютера (всегда) <br>
                        94.100.190.0/23 - адрес подсети (значит, что первые 23 знака значащие, а остальные там нули, адресует группу компьютеров) <br>
                        10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 - private ip (неуникальные адреса) существуют из-за нехватки адресов. Используются для адресации компьютеров во внутренней сети. Пакет нельзя отправлять на такой адрес. Передача с этого адреса происходит не через внутренний, а через внешний IP, существующий у внутренней группы.<br>
                        224.0.0.0 - 239.255.255.255 - multicast ip</p>
                        
                        <h4>IP дейтаграмма</h4>
                        <img src="images/articles/IP-Datagram.jpg" alt="IP-Datagram айпи дейтаграмма передача данных модель OSI">
                        <p>При передаче по IP данные оборачиваются заголовками и получается IP дейтаграмма. Указывается версия, type of servie позволяет с разной скоростью поставлять данные, то есть оптимизировать пакетную маршрутизацию. В заголовке указывается полная длина. Это необходимо, чтобы маршрутизатор полностью смог прочитать заголовок. Есть поле source IP адреса и destination ip Адреса. Это айпишники, с которого и на который передаются данные. Time to live -  каждый раз когда ваш пакет проходит через маршрутизатор у него уменьшается time to live. Когда он прошел 127 шагов, пакет отбрасывается. Это делается для того, чтобы избежать блуждающих пакетов в сети. Поле protocol служит для того, чтобы знать, какому протоколу верхнего уровня нужно передавать данные.</p>
                        <h2>Алгоритм роутера (маршрутизатор)</h2><br>
                        <ul class="articles-lists-ul">
                            <li>Получение дейтаграммы, определение IP получателя</li>
                            <li>Поиск в таблице маршрутизации</li>
                            <li>Не найдено - отбрасываем пакет</li>
                            <li>Выбор наиболее приоритетного маршрута (по префиксу, по дистанции, по ширине канала)</li>
                            <li>Передача дейтаграммы через нужный интерфейс</li>
                        </ul>
                        <p>Есть маршрутизация статическая и динамическая. Статическая - каждый маршрутизатор сконфигурирован вручную. Если маршрутизаторов много, то вручную конфигурировать их неудобно. И здесь включается динамические протоколы маршрутизации. Администратор конфигурирует маршрутизатор, прописывая информацию только о его сетях. Но роутеры могут общаться между собой. Статическая маршрутизация - config</p>
                        <p>Внутренняя - RIP и OSPF
                            <ul class="articles-lists-ul">
                                <li>Работает в небольших сетях</li>
                                <li>Каждый маршрутизатор вычисляет полную таблицу маршрутов</li>
                            </ul>
                        </p>
                        <p>Внешняя BGP и EGP
                            <ul class="articles-lists-ul">
                                <li>Обмен маршрутами на уровне автономных систем (AC)</li>
                                <li>Маршрутные политики</li>
                            </ul>
                        </p>
                        <p><b>Внутренняя</b> предполагает обмен данными, какие сети к ним подключены и в каком состоянии они находятся. Постепенно маршрутизатор строит полный граф сети. То есть, каждый маршрутизатор знает полную структуру сети, какой IP адрес на какой порт надо передавать и насколько далеко нужно передать. После того, как построен полный граф сети, маршрутизатор может найти кратчайший путь. Проблема возникает, когда сеть становится слишком большой. Слишком большой граф сети.</p>
                        <p><b>Внешняя</b>. Представим провайдера, который еще называют автономной системой. Внутри провайдера работает внутренняя маршрутизация. Также у него есть граничный маршрутизатор, который подключен к внешнему миру. Таких маршрутизаторов меньше, и обмениваются они по своему протоколу BGP. Администраторы могут настраивать политики маршрутизаторов, то есть с кем хотим обмениваться, а с кем нет. Но результат тот же. У граничных маршрутизаторов все также, как и во внутренних, просто граф меньше.</p>
                        <h2>DNS (domain name system)</h2>
                        <p>Глобальная распределенная база доменных имен распределяет доменные записи на IP адреса и не только. У DNS протокола единственная функция спросить айпишник у домена. Перед обращением к серверу, сначала происходит запрос к DNS.</p>
                        <ul class="articles-lists-ul">
                            <li>/etc/hosts - локальные DNS записи имеют приоритет</li>
                            <li>Домен - поддерево в пространстве доменных имен, домены обладают иерархией</li>
                            <li>DNS зона (сегмент) - часть базы DNS, хранящаяся под единым административным управлением, зоны не перекрываются</li>
                            <li>RR - resource record - данные, связанные с доменом</li>
                        </ul>
                        <p>Как решалась проблема, что IP нужно запоминать? Система имеет список имен и их айпишников. Вы пишете имя, система подставляет IP, соответствующее имени. В unix системах эти записи хранятся в /etc/hosts. Хосты активно используются когда вам необходимо дать имя, но не хочется лезть в DNS. Например, имя локального компа прописать можно как раз в хостах. Также, вирусы любят прописывать в хостах имя, например, вк и свой айпишник. В этом случае, набирая в поисковой строке вк, открываться будет тот IP, который вирус прописал в хостах, а не сайт вконтакте.</p>
                        <p>Доменных имен стало много, соответственно пришло время хранить имена в базе данных. Почему нельзя хранить БД на одной машине? Это слишком сложно. Большое количество запросов. DNS обладает распределенной архитектурой.</p>
                        <p>При запросе от пользователя, данные передаются на DNS сервер (прописан провайдером, но можно воспользоваться другим при настройке). Если там IP не находится, то сервер пытается подняться вверх по уровню доменов. Корневые DNS сервера знают все. Перенаправляется запрос к DNS верхнего уровня, с верхнеуровневого доменного сервера приходит ответ, что нужно сходить в зону ру, например. Зона ру отправляет на сервер мейл, оттуда мейл отправляет айпишник...</p>
                        <p>Запрос к DNS есть <b>рекурсивный и итеративный</b></p>
                        <p>Рекурсивный запрос предполагает, что то, что вы запрашиваете, вам вернется в ответ.</p>
                        <p>Итеративный запрос, когда машина сама ходит по всем серверам (в отличии от рекурсивного, где после запроса, сервер проделывает работу за вас). DNS сервер провайдера делает итеративные запросы.</p>
                        <p>Самая большая нагрузка на корневой сервер. Так как к нему много запросов. Чтобы сократить нагрузку, используется кэширование.</p>
                        <p>В DNS хранятся записи (не только IP).</p>
                        <p><b>Что не решает IP</b></p>
                        <ol class="articles-lists-ul">
                            <li>Невозможно адресовать конкретное приложение</li>
                            <li>Нет надежной доставки данных</li>
                            <li>Нет порядка дейтаграмм (нет последовательности доставки данных)</li>
                            <li>Нет контроля потока</li>
                        </ol>
                        <p>Протокол TCP (выше уровнем) решает все задачи, описанные выше.</p>
                        <h2>Протокол TCP</h2>
                        <p>Задачи протокола:</p>
                        <ol class="articles-lists-ul">
                            <li>Адресация приложения в пределах хоста (адресовать программу внутри машины)</li>
                            <li>Последовательное двустороннее соединение (данные передаются последовательно)</li>
                            <li>Надежная доставка (обработает все потери, искажения пакетов)</li>
                            <li>Управление потоком (невозможность передать больше данных, чем на другой стороне система может потребить)</li>
                        </ol>
                        <p>Порты:</p>
                        <ol class="articles-lists-ul">
                            <li>Well-known: SSH=20, FTP=21,22,  HTTP=80, SMTP=25, POP3=110</li>
                            <li>Привилегированные (<1024)</li>
                            <li>Остальные (>=1024)</li>
                        </ol>
                        <p>Сокеты (sockets)</p>
                        <ol class="articles-lists-ul">
                            <li>Серверные (bind, listen, accept)</li>
                            <li>Клиентские (connect, send, recv)</li>
                        </ol>
                        <p><b>Порт</b> - это адрес программы внутри одной машины (в рамках одного IP адреса). Низкие порты предназначаются, как правило, для системных служб (привилегии суперпользователя необходимы). Высокие порты можно открывать от имени текущего пользователя.</p>
                        <p><b>Сокет</b> - файловый дескриптор, в который можно писать и читать данные (почти как в обычный файл). Сокеты клиентские - последовательный ввод, вывод. Серверный - дескриптор для создания клиентских сокетов.</p>
                        <img src="images/articles/socket.jpg" alt="socket сокеты порты модель OSI">
                        <p>Сокет - пара IP и порт. За 80 портом закреплены веб сервера</p>
                        <h4>TCP сегмент</h4>
                        <img src="images/articles/TCP.jpg" alt="TCP сегмент модель OSI">
                        <p>В заголовок включается порт получателя и порт отправителя.</p>
                        <p>SEQUENCE NUMBER показывает номер сегмента в потоке. При передаче данных по TCP данные разбиваются на сегменты. У каждого сегмента есть свой номер. При последовательной передачи этот номер постепенно возрастает.</p>
                        <p>ACKNOWLEDGEMENT NUMBER - номер сегмента, который успешно дошел до получателя.</p>
                        <p>SEQUENCE NUMBER отправлен, например, с номером 3. Если в ответ пришел ACKNOWLEDGEMENT NUMBER с таким же номером (3), то означает, что сегмент дошел. Если номер меньше, значит оппонент еще не принял сегмент 3. С помощью SEQUENCE NUMBER упорядочиваются сегменты и появляется возможность надежной доставки.</p>
                        <p>Далее идет поле, в котором указывается длина заголовка. Указываются флажки TCP протокола. Они обеспечивают разные модификации. Один из часто используемых флажков - push - данные о том, что на стороне получателя данные не нужно буферизовать.</p>
                        <p>Window size - опция, которая позволяет управлять потоком передачи. В параметре показывается размер буфера, который свободен.</p>
                        <p>Checksum - позволяет проверить, что данные не были искажены. Если чексуммы совпадают, то сегмент передан правильно. Если чексуммы не совпадают, то протокол отбрасывает пакет и отвечает со старым ACKNOWLEDGEMENT NUMBER. Пакет, который не дошел до получателя будет отправляться повторно до тех пор, пока не будет получен ответ с нужным ACKNOWLEDGEMENT NUMBER. Если искажена чексумма, тогда ошибка не будет обнаружена.</p>
                        <p>Важные флажки SIN, ACK, FIN используются при управлении соединением. Чтобы установить соединение, нужно договориться об SEQUENCE NUMBER. Для этого в первом сегменте отправляется флаг SIN</p>
                        <h2>TCP handshake</h2>
                        <img src="images/articles/TCP handshake.jpg" alt="TCP handshake тройное рукопожатие модель OSI">
                        <p>Round trip time (0.5ms/150ms) - время путешествия туда и обратно. Актуально кэширование соединения.</p>
                        <p>SIN - дает понять о том, что это TCP соединение. Оппонент в момент приема соединения резервирует данные и отправляет флаг SIN и свой флаг ACK. В этих значениях первоначально передается значение SEQUENCE NUMBER. И после этого отправляется сообщение о том, что SIN и ACK приняты. После этого происходит соединение. Схема - тройное рукопожатие.</p>
                        <p>Есть бесплатные сетевые утилиты, например, Wireshark для отслеживания работы TCP</p>
                        <p>TCP для программеров доступен через клиентский сокет. Для создания TCP сервера сначала необходимо импортировать библиотеку сокетов. Подробнее о сокетах будет в статье о web серверах (статья в процессе написания).</p>
                        <h2>HTTP</h2>
                        <p>Методы:</p>
                        <ul class="articles-lists-ul">
                            <li>OPTIONS - запрос методов сервера (Allow)</li>
                            <li>GET - запрос документа (условный get)</li>
                            <li>HEAD - аналог GET, но без тела запроса</li>
                            <li>POST - передача данных клиент</li>
                            <li>PUT - размещение файла по URI</li>
                            <li>DELETE - удаление файла по URI</li>
                            <li>TRANCE, LINK, UNLINK, CONNECT -  редко используются</li>
                        </ul>
                        <p>Коды состояния: <br>
                        1хх - информационные <br>
                        2хх - успешное выполнение <br>
                        200 - ок <br>
                        204 - NoContent (только заголовки) <br>
                        206 - PfrtitialContent (часть ответа) <br>
                        3хх - перенаправления <br>
                        301 - Moved Permanently (seo, кэширование) <br>
                        302 - found (логика работы сайта) <br>
                        304 - Not Modified (при условном GET) <br>
                        4xx - Ошибка контента <br>
                        400 - Bad Request (размер, формат) <br>
                        401 - Unautorized (запрос авторизации) <br>
                        403 - Forbidden (allow, deny) <br>
                        404 - Not found <br>
                        408 - Request Timout (на чтение) <br>
                        418 - I`m teaport <br>
                        5xx - ошибка сервера <br>
                        500 - Internal Server Error <br>
                        502 - Bad Gateaway (проксирование) <br>
                        503 - Service Unavalible <br>
                        504 - Gateway  Timeout <br>
                        505 - HTTP version not supported <br>
                        507 - Insufficient Storage</p>
                        <p><b>Заголовки HTTP запросов</b> построены в виде ключ: занчение, после которых два пробела (два перевода строки), что и означает конец сообщения. <br><br>
                        В первой строке содержится метод запроса, часть URL (вся, кроме домена), путь и версия HTTP запроса. <br>
                        Host - указание домена, вирт.хостинг <br>
                        User-Agent - описание клиентов <br>
                        Accept* - поддержка MIME типов, кодировок, языков и тп <br>
                        Cookie - куки для данной страницы <br>
                        Referer - текущая страница (существует для сбора статистики, проверяя откуда мы пришли) <br>
                        if-Modified-Since - условный GET <br>
                        Connection - управление соединением <br>
                        Content-Type - MIME тип документа (строка, чем она является) <br>
                        Content-Length - размер документа <br>
                        Content-Encoding - кодирование документа <br>
                        Date - текущее время сервера <br>
                        Expires - время актуальности документа <br>
                        Last-Modified - время изменения файла <br>
                        Set-Cookie - установка кук для данного URI <br>
                        Connection - управление соединением</p>

                        <p><b>MIME типы</b> - унифицированное название для разных типов данных. <br>
                        text/html <br>
                        text/css <br>
                        text/javascript <br>
                        image/png <br>
                        video/mp4 <br>
                        application/json</p>
                        <p>Пример HTTP запроса: <br>
                        GET /path/page.html?a=1&b=2 HTTP/1.1 <br>
                        Host: mydomain.com <br>
                        Connection: keep-alive <br>
                        Accept: text/html <br>
                        User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) <br>
                        Referer: http://mydomain.com/page0.html <br>
                        Accept-Encoding: gzip, deflate <br>
                        Accept-Language: ru-RU,ru <br>
                        Cookie: j4i3clrjqqbopkn1nucg1lg0; tncu_cu=1; tncu_any=1 <br>
                        If-None-Match: "2b544b-4cf7-2a98c2c0” <br>
                        If-Modified-Since: Tue, 20 Apr 2010 05:15:31 GMT</p>
                        
                        <p>Стоит отметить, что первым всегда обращается с запросом клиент. Сервер к клиенту первым обратиться не может.</p>

                        <p>Пример HTTP ответа: <br>
                        HTTP/1.1 200 Ok <br>
                        Date: Wed, 23 Sep 2015 10:09:09 GMT <br>
                        Content-Type: text/html; charset=UTF-8 <br>
                        Expires: Wed, 23 Sep 2015 10:09:09 GMT <br>
                        Last-Modified: Wed, 23 Sep 2015 10:09:09 GMT <br>
                        Set-Cookie: yp=; Expires=Sun, 25-Sep-2005 10:09:09 GMT; <br>
                        Path=/
                        Set-Cookie: yp=; Expires=Sun, 25-Sep-2005 10:09:09 GMT; <br>
                        Domain=.www.yandex.ru; Path=/ <br>
                        Content-Encoding: gzip <br>
                        Content-Length: 12032</p>
                        <p>В ответе сервера в первой строке указывается тот самый код ответа (состояния). В последнем заголовке указывается какое количество данных нам пытаются отправить (длина содержимого) для того, чтобы ориентироваться сколько данных нам будет отправлено, сколько нам читать и можем ли мы вычитать именно столько. С помощью этого поля браузер пытается вычислить, а не отправляют ли нам слишком много данных, а также может проверить, пришли все данные или нет.</p>
                        <p>HTTP согласование содержимого. При отправки запроса, дополнительно отправляются заголовки accept (accept-Charset, Accept-Encoding, Accept-Languages, User-Agent). Это означает, что клиент готов принять такую-то кодировку, такую-то раскладку символов, такие-то языки, такие-то типы файлов и тд. Браузер тем самым сообщает серверу, что он умеет. Сервер обязан поступить в соответствии с этим. И выдать заголовок very. Таким образом согласовывается содержимое. Например, переходя на google с русской ОС, вы попадаете на google русский. Браузер отправил серверу данные о том, что вы используете русский язык и сервер в свою очередь приоритетно отправил вам страницу на русском языке.</p>
                        <p>Управление соединением. При отправке запроса можно послать connection двух типов: close и keep-alive. Первый означает, что после получения ответа можно закрыть соединение (имеется ввиду TCP соединение). А второй предполагает, что соединение закрыто не будет. Например, при отдаче html страницы сервер должен еще подгрузить несколько картинок. И для того, чтобы не тратить время на несколько соединений, keep-alive позволяет по одному соединению отправить и html и картинки многое другое.</p>
                        <p>Кэширование. Мы можем к заголовку GET добавить expires. Например, мы запрашиваем у сервера данные и просим их прислать только в том случае, если они изменились после указанной даты в заголовке expires. Если данные не изменились, то в ответе сервер пришлет заголовок с кодом 304 Not Modified.</p>
                        <p>Cookie. Возможность хранить какую-то индивидуальную информацию в браузере. При повторном обращении, если у нас указаны были cookie, у нас в запросе будут указаны cookie (в виде ключ - значение).</p>
                        <p>Перенаправления. Они хорошо работают с заголовками set-cookie. То есть, если прийти, например, на яндекс, то сервер выделит куки, в ответе вернет set-cookie, перенаправит на тот же яндекс, но с куки, то есть, неким образом нас авторизует и в дальнейшем будет знать, что это мы "ходим" по яндексу. Также редирект используется например, при публиковании поста. Вы отправляете POST запрос, а сервер вас редиректит на ту же страницу, но с уже опубликованным постом.</p>
                        <p>Помимо HTTP существует защищенная версия HTTPs. Последний протокол использует два инструмента для защиты. С одной стороны это SSL/TLS протокол, который обеспечивает шифрование данных, то есть данные отправляются не в явном виде. Второй инструмент, который обеспечивает защищенность данных - подпись цифровым сертификатом. Существует два вида сертификатов: публичный (pablic), приватный (private) ключ. Публичный ключ - это когда при первом обращении по https вы отправляете запрос получателю с вопросом, поддерживает ли он данный протокол. Если поддерживает, то вы запрашиваете у него публичный ключ. Публичный ключ своего рода документ, удостоверяющий личность. Как наш компьютер понимает, что отправленный нам ключ с информацией о подлинности сертификата не фейк? В каждой ОС есть встроенное хранилище ключей/сертификатов, которое поставляется производителем ОС. Если подлинность ключа подтверждается, мы запрашиваем приватный ключ, которым мы будем подписывать отправленные сообщения. Приватный ключ имеет срок годности. Он валидный до определенного числа. Сделано это в целях безопасности. Этот ключ также содержит информацию, каким образом будут шифроваться данные. Два эти подхода увеличивают защищенность.</p>
                        
                        
                        <h2>Email</h2>
                        <p>Текстовое сообщение, похожее на текстовый файл</p>
                        <p>MIME  позволяет в одной сущности передавать несколько документов.</p>
                        <p>Задачи:</p>
                        <ul class="articles-lists-ul">
                            <li>Передача не ASCII текста через ASCII канал</li>
                            <li>Передача не текстовых приложений</li>
                            <li>Передача текста из нескольких частей</li>
                            <li>Передача не ASCII заголовков</li>
                        </ul>
                        <p>Вот такой получился краткий конспект. Позднее я планирую посмотреть еще несколько материалов на эту тему и, возможно, дополню эту статью. Полагаю, что некоторые аспекты все же стоит изучить подробнее и раскрыть тему более широко. Но у меня все впереди :)</p>
                        <p>Материалы по теме:</p>
                        <ul class="articles-lists-ul">
                            <li><a class="article-links" href="https://www.youtube.com/watch?v=7HL2xLSOYpI">Сетевые протоколы. Автор: НОУ ИНТУИТ</a></li>
                            <li><a class="article-links" href="https://www.youtube.com/watch?v=PsLzEAsphbM&index=1&list=PLrCZzMib1e9pg7ZLIOhmGSlmkMf8yEOLZ">Веб-разработка. Введение, сетевые протоколы. Автор: Технострим Mail.Ru Group</a></li>
                            <li><a class="article-links" href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI">Сетевая модель OSI. Википедия</a></li>
                            <li><a class="article-links" href="https://www.youtube.com/watch?v=-jR7mGCNXBo&list=PLgVOneHFAXevL9vE-OMZIE3ClDTvnXDO6&index=12">Web Testing. Урок 2. Протокол HTTP. Структура запроса/ответа. Автор: ITVDN</a></li>
                        </ul>

                        <p class="ps-text">Опубликовано: <time datetime="2017-06-11T01:05">07.02.2017</time></p>
                        </div>
                    </article>
                    
                </div>
    		</div>


    		<div class="footer">
        		<div class="social-links scrollflow -opacity">
    				<a href="https://www.facebook.com/anastasia.ekimova.3" target="_blank" class="fb"></a>
    	             <a href="https://vk.com/id812724" target="_blank" class="vk"></a>
    	             <a href="https://www.instagram.com/aasalikova/" target="_blank" class="insta"></a>
    	             <a href="https://twitter.com/AASalikova" target="_blank" class="tv"></a>
    			</div>
    			<div class="copyright scrollflow -opacity"><p>&#169; Anastasia Salikova 2017</p></div>
    		</div>
	    </div>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script type="text/javascript" src="js/YouTubePopUp.jquery.js"></script>
	<script src="js/general.js"></script>
	<script src="js/eskju.jquery.scrollflow.js"></script>


	</body>
</html>